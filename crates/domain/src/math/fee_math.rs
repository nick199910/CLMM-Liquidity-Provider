//! Fee tier calculations for CLMM pools.
//!
//! This module provides functions for calculating fees in concentrated
//! liquidity pools, including fee tier conversions and fee accumulation.

use rust_decimal::Decimal;
use rust_decimal::prelude::{FromPrimitive, ToPrimitive};

/// Standard fee tiers in basis points (1 bp = 0.01%).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FeeTier {
    /// 1 basis point (0.01%) - Stable pairs.
    Bp1 = 1,
    /// 5 basis points (0.05%) - Stable pairs.
    Bp5 = 5,
    /// 30 basis points (0.30%) - Standard pairs.
    Bp30 = 30,
    /// 100 basis points (1.00%) - Exotic pairs.
    Bp100 = 100,
    /// 200 basis points (2.00%) - Very volatile pairs.
    Bp200 = 200,
}

impl FeeTier {
    /// Returns the fee rate as a decimal (e.g., 0.003 for 30 bps).
    #[must_use]
    pub fn as_decimal(&self) -> Decimal {
        Decimal::from(*self as u32) / Decimal::from(10_000)
    }

    /// Returns the fee rate in basis points.
    #[must_use]
    pub fn as_bps(&self) -> u32 {
        *self as u32
    }

    /// Returns the fee rate as a percentage (e.g., 0.30 for 30 bps).
    #[must_use]
    pub fn as_percentage(&self) -> Decimal {
        Decimal::from(*self as u32) / Decimal::from(100)
    }

    /// Creates a fee tier from basis points if it matches a standard tier.
    #[must_use]
    pub fn from_bps(bps: u32) -> Option<Self> {
        match bps {
            1 => Some(Self::Bp1),
            5 => Some(Self::Bp5),
            30 => Some(Self::Bp30),
            100 => Some(Self::Bp100),
            200 => Some(Self::Bp200),
            _ => None,
        }
    }
}

/// Converts basis points to a decimal fee rate.
///
/// # Arguments
/// * `bps` - Fee in basis points (1 bp = 0.01%)
///
/// # Returns
/// Fee rate as decimal (e.g., 30 bps -> 0.003)
#[must_use]
pub fn bps_to_decimal(bps: u32) -> Decimal {
    Decimal::from(bps) / Decimal::from(10_000)
}

/// Converts a decimal fee rate to basis points.
///
/// # Arguments
/// * `rate` - Fee rate as decimal (e.g., 0.003)
///
/// # Returns
/// Fee in basis points (e.g., 0.003 -> 30)
#[must_use]
pub fn decimal_to_bps(rate: Decimal) -> u32 {
    (rate * Decimal::from(10_000)).to_u32().unwrap_or(0)
}

/// Calculates the fee amount from a swap volume.
///
/// # Arguments
/// * `volume` - The swap volume
/// * `fee_rate` - Fee rate as decimal (e.g., 0.003 for 0.3%)
///
/// # Returns
/// The fee amount
#[must_use]
pub fn calculate_fee_amount(volume: Decimal, fee_rate: Decimal) -> Decimal {
    volume * fee_rate
}

/// Calculates the LP's share of fees based on their liquidity share.
///
/// # Arguments
/// * `total_fees` - Total fees generated by the pool
/// * `lp_liquidity` - LP's liquidity in the pool
/// * `total_liquidity` - Total liquidity in the pool
///
/// # Returns
/// LP's share of the fees
#[must_use]
pub fn calculate_lp_fee_share(
    total_fees: Decimal,
    lp_liquidity: u128,
    total_liquidity: u128,
) -> Decimal {
    if total_liquidity == 0 {
        return Decimal::ZERO;
    }

    let lp_share = Decimal::from(lp_liquidity) / Decimal::from(total_liquidity);
    total_fees * lp_share
}

/// Calculates fees earned per unit of liquidity.
///
/// This is useful for comparing fee efficiency across different positions.
///
/// # Arguments
/// * `fees_earned` - Total fees earned
/// * `liquidity` - Liquidity amount
/// * `time_hours` - Time period in hours
///
/// # Returns
/// Fees per unit liquidity per hour
#[must_use]
pub fn calculate_fee_rate_per_liquidity(
    fees_earned: Decimal,
    liquidity: u128,
    time_hours: u64,
) -> Decimal {
    if liquidity == 0 || time_hours == 0 {
        return Decimal::ZERO;
    }

    fees_earned / Decimal::from(liquidity) / Decimal::from(time_hours)
}

/// Estimates fees for a position given pool volume and liquidity distribution.
///
/// # Arguments
/// * `pool_volume_24h` - Pool's 24-hour trading volume
/// * `fee_rate` - Pool's fee rate as decimal
/// * `position_liquidity` - Position's liquidity
/// * `in_range_liquidity` - Total liquidity in the position's tick range
/// * `time_in_range_pct` - Estimated percentage of time price is in range (0.0-1.0)
///
/// # Returns
/// Estimated 24-hour fee earnings for the position
#[must_use]
pub fn estimate_position_fees_24h(
    pool_volume_24h: Decimal,
    fee_rate: Decimal,
    position_liquidity: u128,
    in_range_liquidity: u128,
    time_in_range_pct: f64,
) -> Decimal {
    if in_range_liquidity == 0 {
        return Decimal::ZERO;
    }

    let total_fees = pool_volume_24h * fee_rate;
    let liquidity_share = Decimal::from(position_liquidity) / Decimal::from(in_range_liquidity);
    let time_factor = Decimal::from_f64(time_in_range_pct).unwrap_or(Decimal::ZERO);

    total_fees * liquidity_share * time_factor
}

/// Calculates the effective fee tier considering protocol fees.
///
/// Some protocols take a cut of the trading fees before distributing to LPs.
///
/// # Arguments
/// * `fee_rate` - Base fee rate
/// * `protocol_fee_pct` - Protocol's fee percentage (e.g., 0.10 for 10%)
///
/// # Returns
/// Effective fee rate for LPs after protocol cut
#[must_use]
pub fn calculate_effective_fee_rate(fee_rate: Decimal, protocol_fee_pct: Decimal) -> Decimal {
    fee_rate * (Decimal::ONE - protocol_fee_pct)
}

#[cfg(test)]
mod tests {
    use super::*;
    use rust_decimal_macros::dec;

    #[test]
    fn test_fee_tier_as_decimal() {
        assert_eq!(FeeTier::Bp1.as_decimal(), dec!(0.0001));
        assert_eq!(FeeTier::Bp5.as_decimal(), dec!(0.0005));
        assert_eq!(FeeTier::Bp30.as_decimal(), dec!(0.003));
        assert_eq!(FeeTier::Bp100.as_decimal(), dec!(0.01));
        assert_eq!(FeeTier::Bp200.as_decimal(), dec!(0.02));
    }

    #[test]
    fn test_fee_tier_as_percentage() {
        assert_eq!(FeeTier::Bp30.as_percentage(), dec!(0.30));
        assert_eq!(FeeTier::Bp100.as_percentage(), dec!(1.00));
    }

    #[test]
    fn test_bps_to_decimal() {
        assert_eq!(bps_to_decimal(30), dec!(0.003));
        assert_eq!(bps_to_decimal(100), dec!(0.01));
        assert_eq!(bps_to_decimal(1), dec!(0.0001));
    }

    #[test]
    fn test_decimal_to_bps() {
        assert_eq!(decimal_to_bps(dec!(0.003)), 30);
        assert_eq!(decimal_to_bps(dec!(0.01)), 100);
    }

    #[test]
    fn test_calculate_fee_amount() {
        let volume = dec!(1000);
        let fee_rate = dec!(0.003); // 30 bps

        let fee = calculate_fee_amount(volume, fee_rate);
        assert_eq!(fee, dec!(3));
    }

    #[test]
    fn test_calculate_lp_fee_share() {
        let total_fees = dec!(100);
        let lp_liquidity = 1000_u128;
        let total_liquidity = 10000_u128;

        let share = calculate_lp_fee_share(total_fees, lp_liquidity, total_liquidity);
        assert_eq!(share, dec!(10)); // 10% of 100 = 10
    }

    #[test]
    fn test_calculate_lp_fee_share_zero_liquidity() {
        let share = calculate_lp_fee_share(dec!(100), 1000, 0);
        assert_eq!(share, Decimal::ZERO);
    }

    #[test]
    fn test_estimate_position_fees_24h() {
        let volume = dec!(1_000_000); // $1M daily volume
        let fee_rate = dec!(0.003); // 30 bps
        let position_liq = 10_000_u128;
        let total_liq = 100_000_u128;
        let time_in_range = 0.8; // 80% of time in range

        let fees =
            estimate_position_fees_24h(volume, fee_rate, position_liq, total_liq, time_in_range);

        // Expected: $1M * 0.003 * 0.1 * 0.8 = $240
        assert_eq!(fees, dec!(240));
    }

    #[test]
    fn test_calculate_effective_fee_rate() {
        let fee_rate = dec!(0.003);
        let protocol_fee = dec!(0.10); // 10% protocol fee

        let effective = calculate_effective_fee_rate(fee_rate, protocol_fee);
        assert_eq!(effective, dec!(0.0027)); // 0.003 * 0.9
    }

    #[test]
    fn test_fee_tier_from_bps() {
        assert_eq!(FeeTier::from_bps(30), Some(FeeTier::Bp30));
        assert_eq!(FeeTier::from_bps(50), None);
    }
}
